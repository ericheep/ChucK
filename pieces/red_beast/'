// red-beast

// Eric Heep
// for Manuel Lima's 2nd Year DMA Recital "Red Light Piano"
// MTIID4LIFE

// beast osc setup
BeastOsc out;
//out.setDest("ceiling", "10.40.129.88", 12001);
out.setDest("ceiling", "localhost", 12001);
out.setDest("wall", "localhost", 12002);

// beast osc row/column setup
[14, 9, 9, 7, 9, 9, 14] @=> int num_rows[];
out.setCols(num_rows.size());
out.setRows("ceiling", [7, 5, 5, 3, 5, 5, 7]);
out.setRows("wall",    [7, 4, 4, 4, 4, 4, 7]);

NanoKontrol n;
Quneo q;

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~ visuals setup
// number of columns
7 => int num_cols;

// utility array class
Utility u;
u.init(num_rows);

// zero
float zero[num_cols][0];

// blink sin
BlinkSin b_sin;
float blink_sin[num_cols][0];

// multi sin
MultiSin m_sin;
m_sin.init(num_cols);
float multi_sin[num_cols][0];

// single sin
SingleSin s_sin;
s_sin.init(num_cols);
float single_sin[num_cols][0];

// orbit sin
OrbitSin o_sin;
o_sin.init(num_cols);
float orbit_sin[num_cols][0];

// all our values
float total_width[num_cols][0];
float total_height[num_cols][0];

// array allocation
for (int i; i < num_cols; i++) {
    num_rows[i] => zero.size;
    num_rows[i] => blink_sin[i].size;
    num_rows[i] => multi_sin[i].size;
    num_rows[i] => single_sin[i].size;
    num_rows[i] => orbit_sin[i].size;
    num_rows[i] => total_width[i].size;
    num_rows[i] => total_height[i].size;
}

// test loop
for (int i; i < num_cols; i++) {
    //m_sin.freq(i, Math.random2f(0.12, 6.1));
    //m_sin.vol(i, Math.random2f(0.8, 1.0));
}

s_sin.freq(Math.random2f(0.1, 0.5));
s_sin.vol(Math.random2f(0.2, 0.3));
o_sin.range(0.2);
o_sin.offset(0.5);
o_sin.speed(0.005);

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ controls setup

int mode, mode_latch;

// updates at framerate (30/fps)
fun void visuals() {
    u.zero(total_width) @=> zero;

    while (true) {
        u.zero(total_width) @=> total_width;
        u.zero(total_height) @=> total_height;

        //b_sin.calc(blink_sin) @=> blink_sin;

        //m_sin.calc(multi_sin) @=> multi_sin;
        //s_sin.calc(single_sin) @=> single_sin;
        o_sin.calc(orbit_sin) @=> orbit_sin;

        
        u.order(total_width, blink_sin, multi_sin, orbit_sin, single_sin) @=> total_width;
        u.order(total_height, blink_sin, multi_sin, orbit_sin, single_sin) @=> total_height;

        // sets every square to red, mainly for mapping
        // u.all(total_width) @=> total_width;
        // u.all(total_height) @=> total_height;
        
        // sends osc
        out.send("width", total_width);
        out.send("height", total_height);
        1::second/30.0 => now;
    }
}

fun void modeFeedback(int val) {
    repeat(3) {
        for (int i; i < val + 1; i++) {
            q.pad(0 + i, "r", 30);
            q.pad(4 + i, "r", 30);
            q.pad(8 + i, "r", 30);
            q.pad(12 + i, "r", 30);
        }
        50::ms => now;
        for (int i; i < val + 1; i++) {
            q.pad(0 + i, "r", 0);
            q.pad(4 + i, "r", 0);
            q.pad(8 + i, "r", 0);
            q.pad(12 + i, "r", 0);
        }
        50::ms => now;
    }
}

// ~~~~~~~~~~~~~~~~~~~~~ sineMode setup 

SinOsc sine_bass => dac.chan(4); 
sine_bass.gain(0.0);
sine_bass.freq(27.5);
b_sin.gain(0.0);


for (int i; i < 4; i++) {
    b_sin => dac.chan(i);
}

int sine_bot[8];
int sine_knob[8];
int sine_latch[8];
int sine_slider[8];

fun void sineMode() {
    if (n.slider[0] != sine_slider[0]) {
        n.slider[0] => sine_slider[0];
        sine_bass.gain(sine_slider[0]/127.0 * 1.0); 
    }
    if (n.slider[1] != sine_slider[1]) {
        n.slider[1] => sine_slider[1];
        b_sin.gain(sine_slider[1]/127.0 * 1.0); 
    }
    if (n.bot[1] > 0 && sine_latch[1] == 0) {
        b_sin.freq(440 * 7);
        spork ~ b_sin.blink(); 
        b_sin.calc(blink_sin, num_cols, num_rows) @=> blink_sin;
        1 => sine_latch[1];
    }
    if (n.bot[1] == 0 && sine_latch[1] == 1) {
        0 => sine_latch[1];
        u.zero(blink_sin) @=> blink_sin;
    }
    if (n.slider[2] != sine_slider[2]) {
        n.slider[2] => sine_slider[2];
        b_sin.gain(sine_slider[2]/127.0 * 1.0); 
    }
    if (n.bot[2] > 0 && sine_latch[2] == 0) {
        b_sin.freq(440 * 6);
        spork ~ b_sin.blink(); 
        b_sin.moveBlink(blink_sin, num_cols, num_rows, 0) @=> blink_sin;
        1 => sine_latch[2];
    }
    if (n.bot[2] == 0 && sine_latch[2] == 1) {
        0 => sine_latch[2];
        u.zero(blink_sin) @=> blink_sin;
    }
    if (n.slider[3] != sine_slider[3]) {
        n.slider[3] => sine_slider[3];
        b_sin.gain(sine_slider[2]/127.0 * 1.0); 
    }
    if (n.bot[3] > 0 && sine_latch[3] == 0) {
        b_sin.freq(440 * 8);
        spork ~ b_sin.blink(); 
        b_sin.moveBlink(blink_sin, num_cols, num_rows, 1) @=> blink_sin;
        1 => sine_latch[3];
    }
    if (n.bot[3] == 0 && sine_latch[3] == 1) {
        0 => sine_latch[3];
        u.zero(blink_sin) @=> blink_sin;
    }
    
}

fun void samplingMode() {

}

int drone_bot[8];
int drone_knob[8];
int drone_latch[8];
int drone_slider[8];

fun void droneMode() {
    for (int i; i < 7; i++) {
        if (n.knob[i] != drone_knob[i]) {
            n.knob[i] => drone_knob[i];
            m_sin.freq(i, sine_knob[i]/127.0 * 30.0);
        }
        if (n.slider[i] != drone_slider[i]) {
            n.slider[i] => drone_slider[i];
            m_sin.vol(i, drone_slider[i]/127.0);
            <<< i >>>;
        }
    }
}

fun void controls() {
    while (true) {
        if (n.rec > 0 && mode_latch == 0) {
            (mode + 1) % 3 => mode;
            1 => mode_latch;
            spork ~ modeFeedback(mode);
        }
        if (n.rec == 0 && mode_latch == 1) {
            0 => mode_latch;
        }
        if (mode == 0) {
            sineMode(); 
        }
        else if (mode == 1) {
            samplingMode();
        }
        else if (mode == 2) {
            droneMode();
        }
        10::ms => now;
    }
}

spork ~ visuals();
spork ~ controls();

while (true) {
    1::second => now;
}
